# Объяснения к решению

Обязательные требования:
- [x] респонсив-форма
- [x] требуемые технологии
- [x] объяснение выбора дополнительных технологий

Опциональные требования:
- [ ] датапикер с форматом `dd.mm.yyyy`
- [x] кастомизация через загрузчик
- [x] Typescript
- [x] поддержка локализации

Загрузчик `TPForm.js` прописывает глобальный объект window объект, управляющий настройками и отображением виджета. Таким образом до него можно добраться из любой части приложения.

Api:
- `set(settings)` - переопределение стандартных настроек виджета
- `render(root)` - определяет куда монтировать виджет. В случае отсутствия аргумента монтирует в body
- `update()` - обновляет виджет после изменения настроек
- `destroy()` - удаляет виджет

Настройки:
- `textColor` - цвет текста
- `buttonColor` - цвет кнопки
- `backgroundColor` - цвет фона виджета
- `i18n` - токены локализации

Локализация:
- `title`
- `description`
- `departPlaceholder`
- `returnPlaceholder`
- `button`

Виджет рендерится в `iframe`. Таким образом требования к респонсиву распространяются на сам виджет, а не на страницу, в которую он встраивается. В процессе эксплуатации могут возникнуть проблемы с CSP. Для этого в документации для пользователей нужно прописать добавление соответствующих политик. Ну или пусть пользователь хранит всю статику у себя.
Для безопасности, исходя из требований задания, нужно добавить только три разрешения `sandbox`: разрешение родителя манипуляцией содержимым, исполнение скриптов и отравку формы.

Ещё одна большая проблема - совместимость. Для нивелирования проблем со стилями подключен PostCSS, который по желанию настраивается. Для решения проблем с кодом можно в сборке заменить транспиляцию на Babel и настроить ему необходимые плагины/пресеты/полифилы.

Для самого виджета был выбран Svelte для задела "на будущее" и упрощения поддержки виджета разработкой (хорошо задокументированная технология, поддерживаемая комьюнити VS свои велосипеды - choose your destiny). К тому же он бессовестно легкий, что очень важно для загрузки. По быстродействию сказать сложно: тестов очень много и где-то он быстрый, где-то медленный, но, во всяком случае, не хуже других аналогов.

Стили в скрипте были сделаны намеренно. На таком малом виджете это не играет особой роли. При большей "жирности", конечно, стоит разделить для лучшего распараллеливания загрузки и кэширования. Исправляется это буквально в три строки.

**Примечание:** стили текста неточные. В макете sketch кегли были недоступны, поэтому font-size определялся на глаз. Для одного элемента даже удалось прикинуть line-height.

**Примечание2:** задачу с датапикером не стал делать, требований слишком мало. А самодеятельность - это кроличья нора, ибо сделать хороший пикер (даже с учётом использования готовых решений и их кастомизации) - это как работа часового мастера - тонко, долго и дорого. Например, на такую [штуку](https://elama.github.io/elamajs-ui-kit/#/Components/Inputs/InputDate) было потрачено около двух-трёх рабочих недель кодирования и постоянного обсуждения с дизайнером.

**Примечание3:** на всякий случай, при выполнении задачи шёл по пути большего комфорта. Задачи бывают разные, и под каждую есть свой молоток. Эту, в зависимости от ряда вводных, можно решить и клиентским рендерингом, и статичным html-файлом(-ами), и небольшим SSR. В данном случае из-за отсутствия продуктовых требований и технических ограничений мне было интересно поковырять незнакомую для себя технологию

### Итого
- TPForm.js - 636 байт min+gzip
- app.js - 4кб min+gzip (с разделением стилей ещё меньше)
